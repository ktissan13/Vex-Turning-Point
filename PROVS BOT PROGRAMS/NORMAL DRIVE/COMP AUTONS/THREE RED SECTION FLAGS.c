#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in2,    power,          sensorAnalog)
#pragma config(Sensor, in3,    gyro,         sensorGyro)
#pragma config(Sensor, in4,    Catapult_Pot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  SONAR_F,        sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  SONAR_B,        sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  Encod_R,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  Encod_L,        sensorQuadEncoder)
#pragma config(Motor,  port1,           Chasis_R1,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl5)
#pragma config(Motor,  port2,           Ball_Intake_1, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Chasis_R2,     tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, dgtl5)
#pragma config(Motor,  port4,           Chasis_R3,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, dgtl5)
#pragma config(Motor,  port5,           Catapult_1,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Catapult_2,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           Chasis_L3,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, dgtl7)
#pragma config(Motor,  port8,           Chasis_L2,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, dgtl7)
#pragma config(Motor,  port9,           Ball_Intake_2, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Chasis_L1,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveLeft, encoderPort, dgtl7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int R_Freq = 50;
int R_Batt = 8628;
int P_Freq = R_Freq * (R_Batt / nImmediateBatteryLevel)
// Initial values for Sensors: in 1 = 854  in 2 = 2288
// Initial values for IMEs: port 1 = 0  port 2 = 0  port 3 = 0
#define RD_ENC SensorValue[Encod_R]
#define LD_ENC (-1*SensorValue[Encod_L])
#define D_gyro SensorValue[gyro]
int gyroTolerance = 0;

// TIME VOID FOR TIME THEORY
void wait(int temp)
{
	wait1Msec( P_Freq * temp);
}

// BALL INTAKE VOID
void Ball_Intake(int power)
{
	motor[Ball_Intake_1] = power;
	motor[Ball_Intake_2] = power;
}

int Initial_Value = 600;
int Final_Value = 2350;
int Error_Margin = 75;
int intake_speed = 0;
int Descorer_Time = 100;
int wait_time = 20;

void Sonar_Chasis_RF(int distance, int speed)
{
	while(abs(SensorValue[SONAR_F]) > distance)
	{
		motor[Chasis_R1]=speed;
		motor[Chasis_R2]=speed;
		motor[Chasis_R3]=speed;
		motor[Chasis_L1]=speed;
		motor[Chasis_L2]=speed;
		motor[Chasis_L3]=speed;
	}
}


void Sonar_Chasis_FF(int distance, int speed)
{
	while(abs(SensorValue[SONAR_F]) < distance)
	{
		motor[Chasis_R1]=speed;
		motor[Chasis_R2]=speed;
		motor[Chasis_R3]=speed;
		motor[Chasis_L1]=speed;
		motor[Chasis_L2]=speed;
		motor[Chasis_L3]=speed;
	}
}

void Sonar_Chasis_RB(int distance, int speed)
{
	while(abs(SensorValue[SONAR_B]) >= distance)
	{
		motor[Chasis_R1]=speed;
		motor[Chasis_R2]=speed;
		motor[Chasis_R3]=speed;
		motor[Chasis_L1]=speed;
		motor[Chasis_L2]=speed;
		motor[Chasis_L3]=speed;
	}
}


void Sonar_Chasis_FB(int distance, int speed)
{
	while(abs(SensorValue[SONAR_B]) <= distance)
	{
		motor[Chasis_R1]=speed;
		motor[Chasis_R2]=speed;
		motor[Chasis_R3]=speed;
		motor[Chasis_L1]=speed;
		motor[Chasis_L2]=speed;
		motor[Chasis_L3]=speed;
	}
}

task LCD(){
	while(true){
		bLCDBacklight = true;
		string mainBattery;
		string expanderBattery;
		sprintf(mainBattery," %0.2f Volts",(float)nImmediateBatteryLevel/1000.0);
		sprintf(expanderBattery," %0.2f Volts",(float)SensorValue[power]/270.0);
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0,0,mainBattery);
		displayLCDString(1,0,expanderBattery);
		wait1Msec(1000);
	}
}

// This Shoots the ball and reloads the catapult, Just need to call the function
// Req: None
void Catapult_Launch() {
	while(SensorValue[Catapult_Pot] >= Initial_Value){
		motor[Catapult_1]=127;
		motor[Catapult_2]=127;
	}
	while(SensorValue[Catapult_Pot] <= Final_Value - Error_Margin){
		motor[Catapult_1]=127;
		motor[Catapult_2]=127;
	}
	motor[Catapult_1] = -50;
	motor[Catapult_2] = -50;
	wait1Msec(5);
	motor[Catapult_1] = 0;
	motor[Catapult_2] = 0;
}
void Brake(){
	motor[Chasis_L1]=50;
	motor[Chasis_L2]=-50;

	motor[Chasis_R1]=50;
	motor[Chasis_R2]=-50;
	wait1Msec(5);
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;

	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
}

// This runs both sides of the chasis
// Reg: speed and time
void Chasis(int speed,int time, bool brake){
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
	wait(time);
	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
	motor[Chasis_R3]=0;
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;
	motor[Chasis_L3]=0;
	if (brake == true)
	{
		Brake();
	}
}

// This runs only the right side of the chasis
// Req: speed and time
void Chasis_R(int speed,int time, bool brake){
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
	wait(time);
	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
	motor[Chasis_R3]=0;
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;
	motor[Chasis_L3]=0;
	if (brake == true)
	{
		Brake();
	}
}

// This runs only the left side of the chasis
// Req: speed and time
void Chasis_L(int speed,int time, bool brake){
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
	wait(time);
	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
	motor[Chasis_R3]=0;
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;
	motor[Chasis_L3]=0;
	if (brake == true)
	{
		Brake();
	}
}

// This turns the robot right
// Req: speed and time
void Turn_Right(int speed,int time, bool brake){
	motor[Chasis_L1]=-speed;
	motor[Chasis_L2]=-speed;
	motor[Chasis_L3]=-speed;
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
	wait(time);
	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
	motor[Chasis_R3]=0;
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;
	motor[Chasis_L3]=0;
	if (brake == true)
	{
		Brake();
	}
}

// This turns the robot left
// Req: speed and time
void Turn_Left(int speed,int time, bool brake){
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
	motor[Chasis_R1]=-speed;
	motor[Chasis_R2]=-speed;
	motor[Chasis_R3]=-speed;
	wait(time);
	motor[Chasis_R1]=0;
	motor[Chasis_R2]=0;
	motor[Chasis_R3]=0;
	motor[Chasis_L1]=0;
	motor[Chasis_L2]=0;
	motor[Chasis_L3]=0;
	if (brake == true)
	{
		Brake();
	}
}


// This spins the ball intake
// Change variable intake_speed anytime within code to change speed
// Req: none
task Intake(){
	while(true){
		Ball_Intake(intake_speed);
	}
}

/*// TURN GYRO
void turn(int degrees10, int speed){
while(ABS(SensorValue[D_gyro]) < degrees10 - 100){
motor[Chasis_R1]=speed;
motor[Chasis_R2]=speed;
motor[Chasis_R3]=speed;
motor[Chasis_L1]=-speed;
motor[Chasis_L2]=-speed;
motor[Chasis_L3]=-speed;
}
motor[Chasis_R1]=0;
motor[Chasis_R2]=0;
motor[Chasis_R3]=0;
motor[Chasis_L1]=0;
motor[Chasis_L2]=0;
motor[Chasis_L3]=0;
}*/

/*// TURN GYRO
void turn_other(int degrees10, int speed){
while(ABS(SensorValue[D_gyro]) > degrees10 - 100){
motor[Chasis_R1]=speed;
motor[Chasis_R2]=speed;
motor[Chasis_R3]=speed;
motor[Chasis_L1]=-speed;
motor[Chasis_L2]=-speed;
motor[Chasis_L3]=-speed;
}
motor[Chasis_R1]=0;
motor[Chasis_R2]=0;
motor[Chasis_R3]=0;
motor[Chasis_L1]=0;
motor[Chasis_L2]=0;
motor[Chasis_L3]=0;
}*/

//function for the right chassis
void right_chassis(int speed){
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
}
//function for the left chassis
void left_chassis(int speed){
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
}
void _chassis(int left_speed, int right_speed){
	right_chassis(right_speed);
	left_chassis(left_speed);
}

void _driveClr(){
	SensorValue[Encod_L] = 0;
	RD_ENC = 0;
}

void _driveForward(int distance, int speed){
	_driveClr()
	speed*=-1;
	int D_error = distance - LD_ENC;
	while(D_error > 0){
		_chassis(speed, speed);
		D_error = distance - LD_ENC;
	}
	_chassis(25,25);
	wait1Msec(100);
	_chassis(0,0);
}

void _driveBack(int distance, int speed){
	_driveClr()
	int D_error = distance - LD_ENC;
	while(D_error < 0){
		_chassis(speed, speed);
		D_error = distance - LD_ENC;
	}
	_chassis(-25,-25);
	wait1Msec(100);
	_chassis(0,0);
}

//function to calibrate gyro
void dgyro_chassis_init(){
	D_gyro = sensorNone;
	wait1Msec(200);
	D_gyro = sensorGyro;
	wait1Msec(100);
}

void _drivegyro(float angle, int speed){
	dgyro_chassis_init();
	//angle = ((345/120)*speed)+angle);
	angle = angle+159;

	if((D_gyro) < angle - 100){
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) < angle - 100){
			//...Continue turning
			right_chassis(-speed);
			left_chassis(speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(25);
		left_chassis(-25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) > angle){
				right_chassis(40);
				left_chassis(-40);
				}else{
				right_chassis(-40);
				left_chassis(40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
		}else{
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) > angle - 100){
			//...Continue turning
			right_chassis(speed);
			left_chassis(-speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(-25);
		left_chassis(25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) < angle){
				right_chassis(-40);
				left_chassis(40);
				}else{
				right_chassis(40);
				left_chassis(-40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
	}
}

void turn(int speed, int angle){
	angle = (82/90)*angle
	while((abs(RD_ENC)) < abs(angle)-15){
		left_chassis(speed);
		right_chassis(-speed);
	}
	if (speed > 0){
		while((abs(RD_ENC)) < abs(angle)){
			left_chassis(20);
			right_chassis(-20);
		}
	}
	if (speed < 0){
		while((abs(RD_ENC)) < abs(angle)){
			left_chassis(-20);
			right_chassis(20);
		}
	}
}

void turnE(int speed, float val){
	_driveClr();
	int error = abs(RD_ENC) - abs(val);
	while((abs(RD_ENC)) < (abs(val))){
		left_chassis(speed);
		right_chassis(-speed);
		error = abs(RD_ENC) - abs(val);
	}
	if (speed > 0){
		left_chassis(-25);
		right_chassis(25);
		wait1Msec(100);
	}
	if (speed < 0){
		left_chassis(25);
		right_chassis(-25);
		wait1Msec(100);
	}
	/*while(abs(RD_ENC) != abs(val) && abs(error) > 0){
		if(abs(RD_ENC) < abs(val)){
			right_chassis(-40);
			left_chassis(40);
			}else{
			right_chassis(40);
			left_chassis(-40);
		}
		error = abs(RD_ENC) - abs(val);
	}*/

}
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
task Catapult(){
	while(true){
		if (vexRT(Btn5U)==1){
			while(SensorValue[Catapult_Pot] >= Initial_Value){
				motor[Catapult_1]=127;
				motor[Catapult_2]=127;
			}
			while(SensorValue[Catapult_Pot] <= Final_Value - Error_Margin){
				motor[Catapult_1]=127;
				motor[Catapult_2]=127;
			}
			motor[Catapult_1] = -50;
			motor[Catapult_2] = -50;
			wait1Msec(5);
			motor[Catapult_1] = 0;
			motor[Catapult_2] = 0;
		}
		else if (vexRT(Btn5D)==1){
			motor[Catapult_1]=127;
			motor[Catapult_2]=127;
		}
		else{
			motor[Catapult_1] = 0;
			motor[Catapult_2] = 0;
		}
	}
}
void pre_auton()
{
	startTask (LCD);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	startTask(Catapult);
	startTask (LCD);
	while (true)
	{
		if (vexRT(Btn8U)==1){
			//BRAKE
			//main controller
			motor[Chasis_L1]=50;
			motor[Chasis_L2]=-50;

			motor[Chasis_R1]=50;
			motor[Chasis_R2]=-50;
		}
		/*else if (vexRT(Btn6D)==1){
		//Opposite drive
		//main controller
		motor[Chasis_L1]=-vexRT(Ch2);
		motor[Chasis_L2]=-vexRT(Ch2);
		motor[Chasis_L3]=-vexRT(Ch2);

		motor[Chasis_R1]=-vexRT(Ch3);
		motor[Chasis_R2]=-vexRT(Ch3);
		motor[Chasis_R3]=-vexRT(Ch3);
		}*/
		else{
			//Normal Chasis drive
			//main controller
			motor[Chasis_L1]=vexRT(Ch3);
			motor[Chasis_L2]=vexRT(Ch3);
			motor[Chasis_L3]=vexRT(Ch3);

			motor[Chasis_R1]=vexRT(Ch2);
			motor[Chasis_R2]=vexRT(Ch2);
			motor[Chasis_R3]=vexRT(Ch2);
		}


		//INTAKE DRIVE
		//Move to partner eventually
		if (SensorValue(Catapult_Pot ) > Final_Value-200){
			Ball_Intake((127*vexRT(Btn6U)) + (-127*vexRT(Btn6D)));
		}
		else{
			Ball_Intake(0);
		}

}}

task autonomous()
{
	startTask (Intake);
	startTask (LCD);
	//Start writing auton code from here on....

	/*---------------------------------------------------------------------------*/ /*GO GET BALL UNDER THE CAP*/

	// Clr Encoder
	_driveClr();

	// RUN INTAKE TO GO GET BALL
	intake_speed = 127;

	// Clr Encoder
	_driveClr();

	// GO TO CAP AND GET BALL
	_driveBack(-1400, 100);

	// COAST STOP
	Chasis(0, 5, false);

	/*---------------------------------------------------------------------------*/ /*GO HIT BLUE SECTION FLAGS*/

	// Clr Encoder
	_driveClr();

	// GO BACK TO RED TILE AND BANG THE WALL
	Sonar_Chasis_RF(35, -75);

	Sonar_Chasis_RF(25, -50);

	// COAST STOP
	Chasis(0, 5, false);

	// Clr Encoder
	_driveClr();

	// GO AWAY FROM THE WALL A BIT
	_driveBack(-100, 50);

	Chasis(0, 5, false);

	// Clear Encoder
	_driveClr();

	// TURN TO FLAGS
	turnE(100, 230);

	// COAST STOP
	Chasis(0, 5, false);

	// GO BACK TO RED TILE AND BANG THE WALL
	Sonar_Chasis_RF(13, -100);

	_driveBack(-800, 75);

	Chasis(0, 5, false);

	// LAUNCH BALLS TO HIT THE FLAGS
	Catapult_Launch();

	Chasis(0, 2, false);

	//_driveForward(400, 120);

	Chasis(0, 5, false);

	turnE(-100, 230);

	intake_speed = -90;

	_driveBack(-650, 100);
}
