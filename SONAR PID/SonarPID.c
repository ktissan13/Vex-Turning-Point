#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    Catapult_Pot,   sensorPotentiometer)
#pragma config(Sensor, in2,    power,          sensorAnalog)
#pragma config(Sensor, in3,    gyro,         sensorGyro)
#pragma config(Sensor, dgtl1,  SONAR_F,        sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  SONAR_B,        sensorSONAR_cm)
#pragma config(Motor,  port1,           Chasis_L1,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           Chasis_L2,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           Chasis_L3,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           Ball_Intake_1, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Catapult_1,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Catapult_2,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           Ball_Intake_2, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Chasis_R3,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           Chasis_R2,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          Chasis_R1,     tmotorVex393HighSpeed_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "library/pid_h.h"
#include "library/simplifications and variables.h"

// gyro tolerance
int gyroTolerance = 5;

// Right Chassis motors
void right_chassis(int speed){
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
}

// Left Chassis motors
void left_chassis(int speed){
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
}

// All Chassis motors'
void _chassis(int speed){
	motor[Chasis_R1]=speed;
	motor[Chasis_R2]=speed;
	motor[Chasis_R3]=speed;
	motor[Chasis_L1]=speed;
	motor[Chasis_L2]=speed;
	motor[Chasis_L3]=speed;
}


//function to calibrate gyro
void dgyro_chassis_init(){
	D_gyro = sensorNone;
	wait1Msec(200);
	D_gyro = sensorGyro;
	wait1Msec(100);
}

pid drivegyro; //gyro PID class

//gyro PID constants
void drivegyro_PID_init(){
	drivegyro.kP = 0.2;
	drivegyro.kI = 0.009;
	drivegyro.kD = 1.5;
}

//not using this function at the moment. It is too slow and requires more tuning.
void drivegyro_PID(int angle){
	drivegyro.target = angle;
	drivegyro_PID_init();
	drivegyro.error = drivegyro.target - abs(D_gyro);
	while(drivegyro.error > 0){
		drivegyro.error = drivegyro.target - abs(D_gyro);

		if(abs(drivegyro.error) < 200)
			drivegyro.integral += drivegyro.error;
		else
			drivegyro.integral = 0;

		if(drivegyro.error == 0) {	drivegyro.integral = 0;	}

		drivegyro.derivative = drivegyro.error - drivegyro.last_error;
		drivegyro.last_error = drivegyro.error;

		int turn_speed = (drivegyro.kP*drivegyro.error)+(drivegyro.integral*drivegyro.kI)+(drivegyro.derivative*drivegyro.kD);
		right_chassis(turn_speed);
		left_chassis(-turn_speed);
		delay(25);
	}
}

void _drivegyro(int angle, int speed){
	if((D_gyro) < angle - 100){
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) < angle - 100){
			//...Continue turning
			right_chassis(speed);
			left_chassis(-speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(-25);
		left_chassis(25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) > angle){
				right_chassis(-40);
				left_chassis(40);
				}else{
				right_chassis(40);
				left_chassis(-40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
		}else{
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) > angle - 100){
			//...Continue turning
			right_chassis(-speed);
			left_chassis(speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(25);
		left_chassis(-25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) < angle){
				right_chassis(40);
				left_chassis(-40);
				}else{
				right_chassis(-40);
				left_chassis(40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
	}
}

void sonar_staright(int distance, int speed)
{
	int gyroVal = D_gyro;

	while(abs(SensorValue[SONAR_F]) > distance)
	{
		_chassis(speed);
		wait1Msec(40);
		if (D_gyro != gyroVal){
			_drivegyro(gyroVal,50);
		}
	}
}

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton()
{
}
task usercontrol()
{
}

task autonomous()
{
}
