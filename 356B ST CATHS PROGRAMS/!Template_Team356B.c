#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    potentiometer_lift, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  left_chassis_encoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  right_chassis_encoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           R_Lift,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           ycable2DriveR, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           R_Shooter,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           C_F_Left,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           C_F_Right,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           L_Shooter,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           ycable1DriveL, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L_Lift,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// TIME THEORY BY TISSAN AND YAHYA
int R_Freq = 50;
int R_Batt = 8628;
int P_Freq = R_Freq * (R_Batt / nImmediateBatteryLevel);
// Initial values for Sensors: in 1 = 854  in 2 = 2288
// Initial values for IMEs: port 1 = 0  port 2 = 0  port 3 = 0

// TIME VOID FOR TIME THEORY
void wait(int temp)
{
	wait1Msec( P_Freq * temp);
}

// ROBOT FUNCTIONS
// chassis void
void driveL(int speed)
{
	motor[C_F_Left] = speed;
	motor[ycable1DriveL] = speed;
}

// Right Drive Void
void driveR(int speed)
{
	motor[C_F_Right] = speed;
	motor[ycable2DriveR] = speed;
}

// Lift Void
void lift(int speed)
{
	motor[R_Lift] = speed;
	motor[L_Lift] = speed;
}

// Claw Void
void flipper(int speed)
{
	motor[Claw] = speed;
}

// Intake void
void _intake(int speed)
{
	motor[Intake] = speed;
}

// Shooter void
void shooter(int speed)
{
	motor[R_Shooter] = speed;
	motor[L_Shooter] = speed;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                            AUTONS VOIDS                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void FLAGS_TOP_4P_BLUE()
{
  // Go back and get the ball
  driveL(-100);
	driveR(100);
	// run shooter
  shooter(127);
  wait(20);
  // stop
  driveL(0);
	driveR(0);
	// run intake
  _intake(127);
  wait(18.1);
  _intake(0);
  // go back to tile
  driveL(100);
	driveR(-100);
	wait(24);
	// turn to flags
	driveL(100);
	driveR(100);
	wait(11);
	/*
	// go back a bit
	driveL(100);
	driveR(-100);
	wait(15);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
	// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  */
  // allign to top flag
  driveL(-100);
	driveR(100);
	wait(14);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
		// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  	// turn to bottom flags
	driveL(100);
	driveR(100);
	wait(1);
	  // allign to bottom flag
  driveL(-100);
	driveR(100);
	wait(13);
	// allign straight
  driveL(100);
	driveR(-100);
	wait(20);
	//brake
	driveL(0);
	driveR(0);

}

 void FLAGS_TOP_4P_RED()
 {
  // Go back and get the ball
  driveL(-100);
	driveR(100);
	// run shooter
  shooter(127);
  wait(19);
  // stop
  driveL(0);
	driveR(0);
	// run intake
  _intake(127);
  wait(18.1);
  _intake(0);
  // go back to tile
  driveL(100);
	driveR(-100);
	wait(21);
	// turn to flags
	driveL(-100);
	driveR(-100);
	wait(9);
	/*
	// go back a bit
	driveL(100);
	driveR(-100);
	wait(15);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
	// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  */
  // allign to top flag
  driveL(-100);
	driveR(100);
	wait(12);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
		// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  	// turn to bottom flags
	driveL(-100);
	driveR(-100);
	wait(2);
	  // allign to bottom flag
  driveL(-100);
	driveR(100);
	wait(12);
	// allign straight
  driveL(100);
	driveR(-100);
	wait(20);
	//brake
	driveL(0);
	driveR(0);

}

void PARKING_BLUE_BOTTOM()
{
	// DRIVE BACK
	driveL(-100);
  driveR(100);
  wait(18);
  // BRAKE
  driveL(0);
  driveR(0);
  // INTAKE BALL
  _intake(127);
  wait(23);
  _intake(0);
  // TURN TO PLATFORM
  driveL(100);
  driveR(100);
  wait(12);
  // GET ON PLATFORM
  driveL(-100);
  driveR(100);
  wait(36);
  // BRAKE
  driveL(0);
  driveR(0);

}

void PARKING_RED_BOTTOM()
{
	// DRIVE BACK
	driveL(-100);
  driveR(100);
  wait(18);
  // BRAKE
  driveL(0);
  driveR(0);
  // INTAKE BALL
  _intake(127);
  wait(23);
  _intake(0);
  // TURN TO PLATFORM
  driveL(-100);
  driveR(-100);
  wait(12);
  // DRIVE ON THE PLATFORM
  driveL(-100);
  driveR(100);
  wait(39.5);
  // BRAKE
  driveL(0);
  driveR(0);

}

void FLAGS_PARKING_TOP_7P_RED()
{
  // GO BACK AND GET BALL
  driveL(-100);
	driveR(100);
	// RUN SHOOTER
  shooter(127);
  wait(19);
  // BRAKE
  driveL(0);
	driveR(0);
	// INTAKE BALL
  _intake(127);
  wait(18.1);
  _intake(0);
  // GO BACK TO THE TILE
  driveL(100);
	driveR(-100);
	wait(20);
	// TURN TO THE FLAGS
	driveL(-100);
	driveR(-100);
	wait(9);
	/*
	// go back a bit
	driveL(100);
	driveR(-100);
	wait(15);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
	// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  */
  // ALLIGN TO MIDDLE FLAGS
  driveL(-100);
	driveR(100);
	wait(12);
	// STOP CHASSIS
	driveL(0);
	driveR(0);
	wait(8);
		// INTAKE BALL TO FLYWHEEL TO SHOOT
	_intake(127);
  wait(27);
  _intake(0);
  	// TURN TO THE BOTTOM FLAG
	driveL(-100);
	driveR(-100);
	wait(2);
	  // HIT BOTTOM FLAG
  driveL(-100);
	driveR(100);
	wait(12.5);

	// GO STARIGHT FOR A BIT
  driveL(100);
	driveR(-100);
	wait(15);
	// TURN A BUT TO STARIGHTEN UP
	driveL(100);
	driveR(100);
	wait(1);
	// GO STARIGHT TO PLATFORM AREA
  driveL(100);
	driveR(-100);
	wait(28.5);
  // TURN TO PLATFORM
	driveL(100);
	driveR(100);
	wait(8.5);
	driveL(0);
  driveR(0);
  // LIFT UP LIFT A BIT
	lift(127);
	wait(2);
	lift(0);
	// GO STARIGHT AND HIT THE WALL
  driveL(100);
	driveR(-100);
	wait(5);
  // BRAKE
	driveL(0);
	driveR(0);
	wait(10);
  // GO BACKARDS ON THE PLATFORM
  driveL(-100);
	driveR(100);
	wait(49.5);
	// BRAKE
	driveL(0);
	driveR(0);

}

void FLAGS_PARKING_TOP_7P_BLUE()
{

  // GO BACK AND GET BALL
  driveL(-100);
	driveR(100);
	// RUN SHOOTER
  shooter(127);
  wait(19);
  // BRAKE
  driveL(0);
	driveR(0);
	// INTAKE BALL
  _intake(127);
  wait(18.1);
  _intake(0);
  // GO BACK TO THE TILE
  driveL(100);
	driveR(-100);
	wait(20);
	// TURN TO THE FLAGS
	driveL(100);
	driveR(100);
	wait(9);
	/*
	// go back a bit
	driveL(100);
	driveR(-100);
	wait(15);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
	// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  */
  // ALLIGN TO MIDDLE FLAGS
  driveL(-100);
	driveR(100);
	wait(12);
	// STOP CHASSIS
	driveL(0);
	driveR(0);
	wait(8);
		// INTAKE BALL TO FLYWHEEL TO SHOOT
	_intake(127);
  wait(27);
  _intake(0);
  	// TURN TO THE BOTTOM FLAG
	driveL(100);
	driveR(100);
	wait(2);
	  // HIT BOTTOM FLAG
  driveL(-100);
	driveR(100);
	wait(12.5);

	// GO STARIGHT FOR A BIT
  driveL(100);
	driveR(-100);
	wait(15);
	// TURN A BUT TO STARIGHTEN UP
	driveL(-100);
	driveR(-100);
	wait(1);
	// GO STARIGHT TO PLATFORM AREA
  driveL(100);
	driveR(-100);
	wait(28.5);
  // TURN TO PLATFORM
	driveL(-100);
	driveR(-100);
	wait(8.5);
	driveL(0);
  driveR(0);
  // LIFT UP LIFT A BIT
	lift(127);
	wait(2);
	lift(0);
	// GO STARIGHT AND HIT THE WALL
  driveL(100);
	driveR(-100);
	wait(5);
  // BRAKE
	driveL(0);
	driveR(0);
	wait(10);
  // GO BACKARDS ON THE PLATFORM
  driveL(-100);
	driveR(100);
	wait(49.5);
	// BRAKE
	driveL(0);
	driveR(0);
}






/*---------------------------------------------------------------------------*/
/*        Description: Competition template for VEX EDR                      */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	while(true){

		// Drive button to flip front and back
		if (vexRT[Btn5U] ==1){
			driveL(-vexRT[Ch2]);
			driveR(vexRT[Ch3]);
		}
		else{
			driveL(vexRT[Ch3]);
			driveR(-vexRT[Ch2]);
		}

		// Button for the lift up and down
		if (vexRT[Btn6UXmtr2] == 1){
			lift(120);
		}
		else if(vexRT[Btn6DXmtr2] == 1){
			lift(-120);
		}
		else if(vexRT[Btn8LXmtr2] == 1){
			lift(-20);
		}
		else{
			lift(0);
		}

		// Button for the shooter for top flag and middle flag
		// This is for the top flag running shooter at full speed
		if (vexRT[Btn5UXmtr2] == 1){
			shooter(127);
		}
		// This is for the middle flag running shooter at 100 speed
		else if(vexRT[Btn5DXmtr2] == 1){
			shooter(100);
		}
		// If none of those buttons are pressed the shooter will not continue
		else{
			shooter(0);
		}

		// Button for the flipper/claw
		// This is to flip the cap while it is in the claw
		if (vexRT[Btn7UXmtr2] == 1){
			flipper(45);
		}
		else if (vexRT [Btn7DXmtr2] == 1){
			flipper (-45);
		}
		else{
			flipper(0);
		}

		// Button for the rubberband intake to bring up to the shooter
		// So the intake can pick up the balls
		if (vexRT[Btn8UXmtr2] == 1){
			_intake(120);
		}
		// So the intake will let the balls out
		else if(vexRT[Btn8DXmtr2] == 1){
			_intake(-120);
		}
		else{
			_intake(0);
		}

		// Brake for the chassis
		if (vexRT[Btn6U] == 1){
			motor[C_F_Left] = -30;
			motor[ycable2DriveR] = 20;
			motor[C_F_Right] = -30;
			motor[ycable1DriveL] = 20;
		}
		else{
			motor[C_F_Left] = 0;
			motor[ycable2DriveR] = 0;
			motor[C_F_Right] = 0;
			motor[ycable1DriveL] = 0;
		}

		// ycable 1 is Left side
		// ycable 2 is Right side
	}
}


/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  //FLAGS_TOP_4P_BLUE(); // LINE 76
  //FLAGS_TOP_4P_RED(); // LINE 143
  //PARKING_BLUE_BOTTOM(); // LINE 210
  //PARKING_RED_BOTTOM(); // LINE 237
  //FLAGS_PARKING_TOP_7P_RED(); // LINE 264
  //FLAGS_PARKING_TOP_7P_BLUE(); // LINE 362
}
