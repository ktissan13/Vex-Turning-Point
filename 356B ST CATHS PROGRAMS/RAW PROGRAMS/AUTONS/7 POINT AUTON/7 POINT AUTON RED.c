#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    potentiometer_lift, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  left_chassis_encoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  right_chassis_encoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           R_Lift,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           ycable2DriveR, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           R_Shooter,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           C_F_Left,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           C_F_Right,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           L_Shooter,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           ycable1DriveL, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L_Lift,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

	int R_Freq = 50;
	int R_Batt = 8628;
	int P_Freq = R_Freq * (R_Batt / nImmediateBatteryLevel)
	// Initial values for Sensors: in 1 = 854  in 2 = 2288
	// Initial values for IMEs: port 1 = 0  port 2 = 0  port 3 = 0

	void wait(int temp)
	{
		wait1Msec( P_Freq * temp);
	}

// Aman Patel
// 356B
// Turning Point
// November 25 2018
// Just Driver Control Program


//drive void
int drive = 0;

// chassis void
void driveL(int speed)
{
motor[C_F_Left] = speed;
motor[ycable1DriveL] = speed;
}

// Right Drive Void
void driveR(int speed)
{
motor[C_F_Right] = speed;
motor[ycable2DriveR] = speed;
}

// Lift Void
void lift(int speed)
{
motor[R_Lift] = speed;
motor[L_Lift] = speed;
}

// Claw Void
void flipper(int speed)
{
motor[Claw] = speed;
}

// Intake void
void _intake(int speed)
{
motor[Intake] = speed;
}

// Shooter void
void shooter(int speed)
{
motor[R_Shooter] = speed;
motor[L_Shooter] = speed;
}

task main()
{

  // Go back and get the ball
  driveL(-100);
	driveR(100);
	// run shooter
  shooter(127);
  wait(19);
  // stop
  driveL(0);
	driveR(0);
	// run intake
  _intake(127);
  wait(18.1);
  _intake(0);
  // go back to tile
  driveL(100);
	driveR(-100);
	wait(20);
	// turn to flags
	driveL(-100);
	driveR(-100);
	wait(9);
	/*
	// go back a bit
	driveL(100);
	driveR(-100);
	wait(15);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
	// run intake to shoot middle flag
	_intake(127);
  wait(28);
  _intake(0);
  */
  // allign to top flag
  driveL(-100);
	driveR(100);
	wait(12);
	// stop chassis
	driveL(0);
	driveR(0);
	wait(8);
		// run intake to shoot middle flag
	_intake(127);
  wait(27);
  _intake(0);
  	// turn to bottom flags
	driveL(-100);
	driveR(-100);
	wait(2);
	  // hit bottom flag
  driveL(-100);
	driveR(100);
	wait(12.5);

	// go straight
  driveL(100);
	driveR(-100);
	wait(15);
	// turn to platform
	driveL(100);
	driveR(100);
	wait(1);
	// go straight
  driveL(100);
	driveR(-100);
	wait(28.5);
  // turn to platform
	driveL(100);
	driveR(100);
	wait(8.5);
	driveL(0);
  driveR(0);
  // lift up
	lift(127);
	wait(2);
	lift(0);
	// go straight on platform
  driveL(100);
	driveR(-100);
	wait(5);
  // brake
	driveL(0);
	driveR(0);
	wait(10);
  // go straight on platform
  driveL(-100);
	driveR(100);
	wait(49.5);
	// brake
	driveL(0);
	driveR(0);
}
