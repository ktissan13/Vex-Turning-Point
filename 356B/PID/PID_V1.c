#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl3,  Encod_L,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Encod_R,   sensorQuadEncoder)
#pragma config(Motor,  port4,           right_mid,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           right_front,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           shooter_right,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           left_back,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           right_back,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           intake_left,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           shooter_left,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           left_front,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          left_mid,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Motors")
#pragma platform(VEX)

void moveBase(int speed)
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
	motor[left_front] = speed;
	motor[left_mid] = speed;
	motor[left_back] = speed;
}

void rightBase(int speed)
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
}
void leftBase(int speed)
{
	motor[left_front] = speed;
	motor[left_mid] = speed;
	motor[left_back] = speed;
}

void turnBase(int speed) // positve is clockwise
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
	motor[left_front] = -speed;
	motor[left_mid] = -speed;
	motor[left_back] = -speed;
}

//TICKS/INCH FORMULA                                                 //TEST THIS OUT
//reading: ticks -- 627.2 ticks/revolution
//1 turn of the wheels -- 4 inch wheels == 627.2*2 ticks
//1 turn of each wheel 4*pi inches
//4*pi inches = 627.2*2 ticks
//ticks/inch = 627.2*2/(4*pi) = 99.82198

//when my error is 30
//the actual error is inches - 30

const float ticksperinch = 99.82198;
const float ticksPerTurn = 2207; // ? not sure you might want to test it first // when you doing this turn robot 360 and add bot encoder values together
const int wheel_base = 11.5; // make sure its in inches
const int wheel_dia = 360;

int fixTimerValue(float rawSeconds)
{
	int miliseconds;
	miliseconds = rawSeconds*1000;
	if(miliseconds < 250)
	{
		miliseconds = 250;
	}
	return miliseconds;
}

int inchToTicks (float inch)
{
	int ticks;
	ticks = inch*ticksperinch;
	return ticks;
}

int degreesToTicks(float degrees)
{
	int ticks;
	ticks = degrees*ticksPerTurn/360;
	return ticks;
}

/*int degreesToTicks(float degrees)
{
	int ticks;
	ticks = degrees*wheel_base/wheel_dia;
	return ticks;
}*/

void PIDbaseControl(float target, float waitTime, float maxPower = 127)
{
	float Kp = 0.5;
	float Ki = 0.0009;
	float Kd = 0.5;
	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	const float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	float Kp_C = 0.01;
	int error_drift;
	float proportion_drift;

	bool timerBool = true;

	SensorValue[Encod_L] = 0;
	SensorValue[Encod_R] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{
		error = inchToTicks(target) - (SensorValue[Encod_L] + SensorValue[Encod_R]);
		proportion = Kp*error;
		if(abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion+derivative+integral
		if (finalPower > maxPower)
		{
			finalPower = maxPower;
		}
		else if (finalPower < -maxPower)
		{
			finalPower = -maxPower;
		}

		error_drift = SensorValue[Encod_R] - SensorValue[Encod_L];
		proportion_drift = Kp_C * error_drift;

		leftBase(finalPower+proportion_drift);
		rightBase(finalPower-proportion_drift);
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

void PIDbaseTurn(float target, float waitTime, float maxPower = 127)
{
	float Kp = 0.75;
	float Ki = -0.0009;
	float Kd = 0.5;
	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	const float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	SensorValue[Encod_L] = 0;
	SensorValue[Encod_R] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{
		error = degreesToTicks(target) - ((SensorValue[Encod_L]) - (-1*SensorValue[Encod_R]));
		proportion = Kp*error;
		if(abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion+derivative+integral
		if (finalPower > maxPower)
		{
			finalPower = maxPower;
		}
		else if (finalPower < -maxPower)
		{
			finalPower = -maxPower;
		}

		turnBase(finalPower);
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	turnBase(0);
}

task main()
{
	PIDbaseTurn(90, 1, 75);
}
